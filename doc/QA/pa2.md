## PA2 - Simple complex machines: Von Neumann computer system

### How does YEMU execute a program?

```c
while (1) {
  /* fetch   */
  opcode = inst.[type].[op];
  switch (opcode) {
    case ...:
      /* decode  */
      /* execute */
      break;
  }
  /* update  */
}
```

### How RISCV-32 encodes 32-bit constants directly into an instruction?

riscv-32 use **2 steps** to accomplish loading command. Firstly, riscv-32 uses `lui` to load the upper 20 bits of a 32-bit constant and place them in a register while padding the lower 12 bits with zeros. Secondly, riscv-32 uses `addi` to add the remaining lower 12 bits of the immediate number to the register.

```assembly
# pseudo-instruction: li t0, 0x12345678
lui t0, 0x12345
addi t0, t0, 0x678
```

### Why is an error message output when an unimplemented instruction is executed?

When an unimplemented instruction is executed, it enters the function `INV(s->pc)`

```c
// nemu/src/isa/riscv32/inst.c
static int decode_exec(Decode *s) {
  INSTPAT_START();
  /* some implemented instruction */
  INSTPAT("??????? ????? ????? ??? ????? ????? ??", inv    , N, INV(s->pc));
  INSTPAT_END();
}

// nemu/include/cpu/cpu.h
void invalid_inst(vaddr_t thispc);
#define INV(thispc) invalid_inst(thispc)

// nemu/src/engine/interpreter/hostcall.c
void invalid_inst(vaddr_t thispc) {
  /* print out some error information with isa logo */
  set_nemu_state(NEMU_ABORT, thispc, -1);
}
```

After outputing the error message, riscv-32 will set nemu state as `NEMU_ABORT`. Then the system will stop.

### RV32M standard extension

When we implement DIV[U] and REM[U], we need to consider some edge conditions.

|    Condition    |  Dividend  | Divisor |    DIVU   | REMU |     DIV    | REM |
|:---------------:|:----------:|:-------:|:---------:|:----:|:----------:|:---:|
| Division by zero|      x     |     0   | $2^{L}-1$ |   x  |     -1     |  x  |
| Overflow        | $-2^{L-1}$ |    -1   |     -     |   -  | $-2^{L-1}$ |  0  |

### Running NEMU in batch mode

When testing, we can set some arguments in Makefile so we don't need to type 'c' and 'q':

```makefile
# abstract-machine/scripts/platform/nemu.mk
NEMUFLAGS += --batch
```

### Disappeared symbol

```c
// am-kernels/tests/cpu-tests/tests/add.c
int add(int a, int b) {
	int c = a + b;
	return c;
}
#define NR_DATA LENGTH(test_data)
```

We define the macro "NR_DATA", and we also define the local variable c and the formal parameters "a" and "b", but we can't find them in the symbol table. Why?

The macro is defined via the preprocessor with the value `LENGTH(test_data)`. During the preprocessing phase before compilation, the macro has been replaced with a specific value.

Local variables and function arguments are not recorded in the symbol table because they don't need to be accessed across functions or files.

### What constitutes a symbol?

A symbol is an entity in a program that can be referenced by name. It usually consists of the following:

* global variables
* static variables
* functions
* special symbols generated by the compiler (e.g., `.text`, `.data`)


### Where is "Hello World!" in the string table?

Write a "Hello World" program under Linux, compile it and find the string table of the ELF file by the above method, where do you find the "Hello World!" string in the string table? Why is it there?

After writing hello.c:

```c
#include <stdio.h>

int main() {
  printf("Hello World!\n");
  return 0;
}
```

Run the following commands and we can get the result:

```shell
gcc -g -o hello hello.c
readelf -x .rodata hello

# result
Hex dump of section '.rodata':
  0x00002000 01000200 48656c6c 6f20576f 726c6421 ....Hello World!
  0x00002010 00  
```

In C, string constants (such as "Hello, World!") are stored as **read-only global data**. The compiler puts string constants into **.rodata** sections to save memory and to ensure that they are not modifiable (read-only property). 

.strtab is specialized for storing symbol-related names (e.g., function names, variable names). "Hello, World!" is a string constant not directly related to a symbol, so it is not stored in .strtab.

### Duplicated symbol table

Write a "Hello World" program under Linux, and then use `strip` command to discard the symbol table in the executable. View the hello infomation using `readelf`:

```shell
gcc -o hello hello.c
strip -s hello
readelf -a hello
```

We'll notice that the symbol table has been discarded, so will the hello program run successfully? **Yes**

There is also a symbol table in the target file, which we can discard as well. View the hello infomation using `readelf`, and we'll find that symbol table is discarded. Try to Trying to link to hello.o:

```shell
gcc -c hello.c
strip -s hello.o
gcc -o hello hello.o

# result
/usr/bin/ld: error in hello.o(.eh_frame); no .eh_frame_hdr table will be created
/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':
(.text+0x1b): undefined reference to `main'
collect2: error: ld returned 1 exit status
```

Try to compare the two situations and analyze the reasons.

* Scenario 1: symbol table of the executable file is discarded
  * Symbol table is important for debugging and disassembly, but at runtime, they are already resolved to specific addresses by the linker, so the program can still run after removing the symbol table from the executable file.
* Scenario 2: symbol table fo target file is discarded
  * **The target file relies on the symbol table at linking time**, which contains global symbols and unresolved external references (e.g, main function). `strip -s` removes the symbol table from hello.o, making it impossible for the target file to provide the necessary symbol information. During the linking phase, the linker needs to resolve the symbol for `main` from the target file but since the symbol table has been removed, the linker cannot find the definition of `main`, resulting in an error.

### Let's see how fast NEMU goes.

* RISC-V 32
  * dhrystone:     119 Marks
  * coremark:      319 Marks
  * microbench:    397 Marks
  *         vs. 100000 Marks (i9-9900K @ 3.60GHz)
* Native
  * dhrystone:   58726 Marks
  * coremark:    48690 Marks
  * microbench:  48162 Marks
  *         vs. 100000 Marks (i9-9900K @ 3.60GHz)

### How the typing game works?

Look at the code: `am-kernels/kernels/typing-game/game.c`

### Compilation and linking

<!-- todo: I need to answer these compulsory answer -->
reference: https://nju-projectn.github.io/ics-pa-gitbook/ics2024/2.5.html#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F